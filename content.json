[{"title":"部署 FRP 反向代理流程","path":"2023/04/14/部署-FRP-反向代理流程/","text":"最近有好几个机器都要用反向代理能力将内网的机器映射出来，做多了就成了机械操作，这里把具体操作流程写下来，方便自己也方便大家参考。 前置条件 有公网 IP 的机器一台 需要映射的机器 N 台 服务端流程 首先在有公网 IP 的机器上部署服务端（server），供其他的机器连接。 下载 FRP 的最新版本 wget https://github.com/fatedier/frp/releases/download/v0.48.0/frp_0.48.0_linux_amd64.tar.gz 解压并放到任意你方便记忆的目录 # 解压 tar -zxvf frp_0.48.0_linux_amd64.tar.gz # 进入文件夹 cd frp_0.48.0_linux_amd64 # 创建文件夹 sudo mkdir /usr/lib/frp # 移动服务端程序 sudo cp frps /usr/lib/frp/ # 移动服务端配置 sudo cp frps.ini /usr/lib/frp/ 前往配置服务端 sudo vim /usr/lib/frp/frps.ini [common] # 其他的也行，与下面客户端配置保持一致即可 bind_port = 7001 token = [YOUR_TOKEN] dashboard_port = 8080 databoard_user = [YOUR_USERNAME] dashboard_pwd = [YOUR_PASSWORD] enable_prometheus = true log_file = /usr/lib/frp/frps.log log_level = info log_max_days = 7 编写服务端程序的系统服务 # 这里是/usr/lib/...，用户级别的系统服务 sudo vim /usr/lib/systemd/system/frps.service [Unit] Description=Frp Server Service After=network.target [Service] Type=simple User=nobody Restart=on-failure RestartSec=5s ExecStart=/usr/lib/frp/frps -c /usr/lib/frp/frps.ini [Install] WantedBy=multi-user.target 使用系统服务的方式启动服务端程序 &amp; 启用开机自动启动 systemctl start frps systemctl enable frps 在浏览器上输入 [IP]:8080 进入控制台（账号密码在第三步设置了），查看服务是否正常启动了。如果出现界面则表示服务端已经正常启动了~🎉 客户端流程 客户端流程基本同上，不同的地方会标识出来。在内网环境的设备上执行以下操作： 下载 FRP 的最新版本 wget https://github.com/fatedier/frp/releases/download/v0.48.0/frp_0.48.0_linux_amd64.tar.gz 解压并放到任意你方便记忆的目录 ⚠️ 移动客户端程序和配置！ # 解压 tar -zxvf frp_0.48.0_linux_amd64.tar.gz # 进入文件夹 cd frp_0.48.0_linux_amd64 # 创建文件夹 sudo mkdir /usr/lib/frp # 移动客户端程序 sudo cp frpc /usr/lib/frp/ # 移动客户端配置 sudo cp frpc.ini /usr/lib/frp/ 前往配置客户端 ⚠️ 配置客户端的配置文件，有所不同！ sudo vim /usr/lib/frp/frpc.ini [common] server_addr = [YOUR_PUBLIC_IP_ADDRESS] server_port = 7001 # 在上面服务端配置的 token token = [YOUR_SERVER_CONFIG_TOKEN] # 这是你在服务端管理界面上看到的名称，可以任意起名。 [cs-lab] type = tcp local_ip = 127.0.0.1 local_port = 22 # 映射到公网的端口 remote_port = 20022 编写客户端端程序的系统服务 sudo vim /usr/lib/systemd/system/frpc.service [Unit] Description=Frp Client Service After=network.target [Service] Type=simple User=nobody Restart=on-failure RestartSec=5s ExecStart=/usr/lib/frp/frpc -c /usr/lib/frp/frpc.ini [Install] WantedBy=multi-user.target 使用系统服务的方式启动服务端程序 &amp; 启用开机自启 systemctl start frpc systemctl enable frpc 在控制台刷新一下查看 proxy，如果出现新条目则表示启动成功了！🎉 Q&amp;A 如果启动出现问题也不用紧张，系统服务虽然当场不会显示错误日志，不过可以通过 journalctl -u frp 命令查看对应的日志从而排查错误。"},{"title":"解决国内 OpenStreetMap 地图无法显示的问题","path":"2023/04/11/解决国内-OpenStreetMap-地图无法显示的问题/","text":"今天去开会，了解到师弟那边项目遇到了一个问题：OpenStreetMap 的地图组件在国内网络环境则加载不出来。本着助人为乐的精神，我主动承担了帮助解决这个问题的任务。 ¶❓问题复现 网站地址： http://sheng.whu.edu.cn/spadas/, 在打开该地址后，可以看到地图上的标注可以加载，但是底图没有出来。像这样子： 在打开 F12 网络情况后发现，和其他的地图加载方式一样，OpenStreetMap 也是使用了地图分块图层的方式加载的，每个区块都是单独在域名下 a.tile.openstreetmap.org 去获取的。而这个域名通过 ping 发现在国内网络是无法访问的： 最终就会导致所有图层的图像获取失败，地图显示空白： ¶👌 解决方案 确认了问题，下面就是去找对应的解决方案。因为已经定位到是域名的问题，那么接下来就直奔主题，去找 OpenStreetMap 的 CDN 加速方案。经过一番搜寻，最终发现 OpenStreetMap 官网 列举出了所有图层数据的服务提供商（免费/商用）域名地址，url 结构大部分为 https://&#123;s&#125;.tile.[DOMAIN]/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png，这和上面的访问失败的结构完全一致，可以断定就是修改这个 URL 即可替换掉图像的获取地址，确保地图的正确加载。 接下来在项目前端代码里搜索 openstreetmap.org该域名，很容易找到了对应的配置项： 最后把这个 url 模板在网站上找一个访问速度快的地址替换掉，地图不加载的问题就解决了🎉"},{"title":"导出微信聊天记录","path":"2022/11/15/导出微信聊天记录/","text":"¶背景 女朋友论文需要引用微信群的聊天记录作为数据分析，因此有导出指定群聊的消息记录的需求。相信有很多重度依赖微信的朋友也有导出微信聊天记录的需求，因此这里过程特做一个记录，希望对大家有帮助~ ¶相关工具 主要使用的工具为 wxbackup，微信聊天记录导出神器。 ¶步骤 连接手机（仅限 iOS）到电脑，建议使用 Mac，虽然上述工具有 windows 客户端，但是在后续导出过程中出现报错导致无法进行下去，还是 MacOS 上比较稳定。 打开 iTunes（老版本是一个独立的 App，新版本 MacOS 已经整合进 Finder 了，直接在 Finder 侧边栏找到对应的设备即可）。 在 iTunes 中操作备份到本机，如图 如果和我情况一样， Mac 空间有限，无法备份到本机，也是有解决办法的，详见下面补充部分说明。 导出完成后，打开上面下载的微信导出工具 wxbackup，启动时会自动检测备份位置的，如果没有找到备份会提示你手动指定目录，这种情况可以指定 ~/Library/Application Support/MobileSync/Backup 目录试试。 貌似是 MacOS 版本更新导致的，旧版本的目录是在 ~/Library/Application Support/Apple/MobileSync/Backup 下。 如果成功检测到备份，工具会自动提取出所有的聊天记录展示为列表，这里就可以选择自己想要导出的群或者单聊选择输出位置直接导出了。 导出的格式为静态网页，打开文件夹后打开 index.html 文件即可预览聊天界面，跟真实的微信聊天界面非常相似（悼念下 web 版微信）。 如果有后续数据处理和数据分析需求的，所有的消息数据是以一个 js 大对象格式存储在 js/message.js 里的，可以编写一点简单的 JavaScript 代码来处理一下，比如转换成 csv 或者 excel 这样子。这里不多做介绍了。 ¶如果 Mac 空间不足无法备份怎么办？ 这里也是有办法的~在网上找到了另一款神器 iMazing，支持将手机直接备份到外部空间上，下载并打开 iMazing，点击备份，即可自行选择备份位置，换到 U 盘或者移动硬盘即可。"},{"title":"爬取微信公众号文章","path":"2022/07/05/爬取微信公众号文章/","text":"¶需求背景 由于微信公众号文章的搜索功能实在是过于孱弱（只支持内容分词匹配+是否最近读过+排序方式），对于某些公众号内的文章需要进行更多的检索就只能自己动手了。 ¶设计思路 总的计划是将文章的内容都爬取下来保存在自己的数据库中，后续需要按照任何条件检索都可以很方便的进行。 微信公众号的文章列表在电脑端都是要在微信内置浏览器内显示的，在外部浏览器强行打开就会提示：请在微信端打开。但是具体一篇文章却是可以在浏览器打开的。因此，获取到文章链接再爬取文章内容相对是比较容易做到的。难点在于如何获取到完整的公众号文章列表。 graph LR 抓取文章列表请求--->爬取文章列表--->爬取文章正文--->梳理文章数据--->输出展示; ¶抓取文章列表请求 由于微信公众号主页不能在浏览器中打开，因此考虑使用抓包工具抓到请求文章列表的请求。 &nbsp;&nbsp;Mac 上大家推荐的大多是 [Charles](https://xclient.info/s/charles.html)这款软件。不过这款软件在我的 mac 上好像有点水土不服，反正就是无法抓到任何请求。 然后就检索到了 windows 上常用的抓包软件 Fiddler 出了一个 Fiddler Everywhere，可以在 MacOS 上安装使用。于是使用了一下，效果拔群！而且软件还支持 http 请求调试（Postman 危），界面也是非常现代化很好看，推荐！ Fiddler 抓到的公众号文章列表请求： ¶爬取文章列表 这一步具体操作就是用代码修改一些参数并重演上述的请求，将相应的结果拼接保存，从而获取整个公众号的所有文章链接~ 将抓取的请求的 url、method、headers、params 都粘贴出来，放到 postman 里修改一下 offset 参数再次请求确认是可以正常执行的： 展开右边的代码，选择你想用的爬虫代码语言版本，我这里用了 python，编写完成后的爬取列表的代码如下： import requests import json def send_req(offset): url = \"https://mp.weixin.qq.com/mp/profile_ext?action=getmsg&amp;__biz=Mzg5OTE4NTczMQ==&amp;f=json&amp;offset=\" + str( offset) + \"&amp;count=10&amp;is_ok=1&amp;...略\" payload = &#123;&#125; headers = &#123; # 略 &#125; response = requests.request(\"GET\", url, headers=headers, data=payload) resp = json.loads(response.text) return resp['general_msg_list'], resp['next_offset'], resp['can_msg_continue'] == 1 if __name__ == '__main__': has_more = True offset = 0 count = 1 all_list = [] while has_more: msg_list, offset, has_more = send_req(offset) print('第' + str(count) + '页:' + msg_list) post_list = json.loads(msg_list) all_list.extend(post_list) count += 1 print(json.dumps(all_list)) 这里有一个小优化点：每次请求拿到的结果是{“list”: […]}，可以先展开再 append。这里懒得弄了就这样吧~后续解析的时候按行解析就行了。 ¶爬取文章正文 获取到列表后观察一下结构： 字段很多，按照自己需求决定将其中的 type（做分组检索可能用得上，虽然还没搞懂枚举值分别是什么含义），datetme（时间范围条件筛选），title，content_url，cover（封面图，后续展示效果优化时可能用得上）这几个字段挑选出来使用。 这里又有一个优化点，在最终展示的时候发现，有很多貌似草稿/已删除的也被查询出来了，这里应该要按照 status 做一次过滤。 将上述几个字段保存到结构体中，并留空 content 字段，等待后续爬正文内容再填充。 ¶转换解析结构体 # Python 中面向对象的编程 class Record: def __init__(self, obj): common = obj['comm_msg_info'] ext = obj['app_msg_ext_info'] self.type = common['type'] self.datetime = common['datetime'] self.title = ext['title'] self.content_url = ext['content_url'] self.cover_url = ext['cover'] self.content = '' with open('wechat.json') as f: has_more = True while has_more: line = f.readline() if line == '' or line == '\\n': has_more = False continue objs = json.loads(line) arr = objs['list'] for obj in arr: results.append(Record(obj)) ¶请求文章正文 读取了文章列表后就可以开始爬取文章数据了。这里用 requests 模块发送 http 请求获取正文，BeautifulSoup 模块解析响应的 html 文档。在 F12 控制台中可以检索到正文对应的文档树节点 id 为&quot;js_content&quot;，用这个 selector 去获取元素及其文本即可。 counter = 0 fails = [] for record in results: url = record.content_url try: resp = requests.get(url) print('get success #' + str(counter)) except Exception: print('get failed #' + str(counter)) fails.append(record) counter += 1 content = resp.content soup = BeautifulSoup(content, 'lxml') text = soup.select('#js_content')[0].getText() # 避免 csv 出错，统一改为中文逗号 text = text.replace(',', '，') record.content = text # TODO 标题也修改为中文逗号 record.title = record.title.replace(',', '，') ¶写入 csv 文件 得到正文后需要保存落库。原本计划是写入数据库，但是看到 yunyoujun 的做菜项目使用了 csv 作为数据源，直接用 ts 代码读取数据而不用连接传统 sql 数据库，考虑到最近也正在看 react 的教程，于是决定也这么做！ # for export to csv titles = ['title', 'datetime', 'content_url', 'content', 'type', 'cover_url'] f = open('database.csv', 'w') with f: writer = csv.DictWriter(f, fieldnames=titles) writer.writeheader() for row in results: writer.writerow(row.__dict__) ¶记录请求失败的case 由于网络等原因，正文获取总会有失败的可能性，这里在 request.get() 的时候记录下了对应的 url（上文的请求文章正文部分的fails.append(record)），最终会汇总输出到控制台，再根据情况考虑如何补上这部分数据。 if len(fails) > 0: print('get ' + str(len(fails)) + 'failed:') for fail in fails: print(json.dumps(fail.__dict__)) 可能是微信公众号的服务比较不稳定或者是我网络不稳定，即使在浏览器中访问文章也有不小的概率失败，因此将请求加了重试，具体见下面的完整代码。 ¶完整代码 import json import requests from bs4 import BeautifulSoup import csv class Record: def __init__(self, obj): common = obj['comm_msg_info'] ext = obj['app_msg_ext_info'] self.type = common['type'] self.datetime = common['datetime'] self.title = ext['title'] self.content_url = ext['content_url'] self.cover_url = ext['cover'] self.content = '' # 加上重试 def try_get(url, times): for time in range(times): try: resp = requests.get(url) if resp.status_code != 200: print('request failed for #' + str(time)) continue return resp except Exception: print('request failed for #' + str(time)) continue raise Exception('failed for ' + str(times) + ' times') if __name__ == '__main__': results = [] with open('wechat.json') as f: has_more = True while has_more: line = f.readline() if line == '' or line == '\\n': has_more = False continue objs = json.loads(line) arr = objs['list'] for obj in arr: results.append(Record(obj)) # for fetch content counter = 0 fails = [] for record in results: url = record.content_url print(url) try: resp = try_get(url, 5) print('get success #' + str(counter)) except Exception: print('get failed #' + str(counter)) fails.append(record) counter += 1 content = resp.content soup = BeautifulSoup(content, 'lxml') text = soup.select('#js_content')[0].getText() # 避免 csv 出错，统一改为中文逗号 text = text.replace(',', '，') record.content = text # TODO 标题也修改为中文逗号 record.title = record.title.replace(',', '，') # for export to csv titles = ['title', 'datetime', 'content_url', 'content', 'type', 'cover_url'] f = open('database.csv', 'w') with f: writer = csv.DictWriter(f, fieldnames=titles) writer.writeheader() for row in results: writer.writerow(row.__dict__) if len(fails) > 0: print('get ' + str(len(fails)) + 'failed:') for fail in fails: print(json.dumps(fail.__dict__)) 至此，爬虫部分的代码就完成啦。所有的公众号文章的内容都已经存入了 database.csv文件里了。后续就可以使用 react 项目去读取并展示了。 ¶梳理文章数据 所有文章信息都导入到了 CSV 里了： 创建一个前端 React 项目： npx create-react-app wechat-app 然后进入项目 src 目录，参考 yunyoujun 的转换代码，将 csv 转换为 json 数据提供给 js 代码引用。 之所以转换的原因是前端代码只能 import 一个 json 文件而不能 import 一个 csv 文件。 转换代码： # csvConverter.ts import fs from 'fs' import path from 'path' import consola from 'consola' const csvFile = path.resolve(__dirname, '../src/asset/database.csv') const jsonFile = path.resolve(__dirname, '../src/asset/database.json') function run() &#123; const csvData = fs.readFileSync(csvFile, 'utf-8') let jsonData: Database = [] const lines = csvData.split(/\\r?\\n/) lines.slice(1).forEach((line)=> &#123; if(line) &#123; const attrs = line.split(',') jsonData.push(&#123; title: attrs[0], datetime: parseInt(attrs[1]), content_url:attrs[2], content:attrs[3], type:parseInt(attrs[4]), cover_url:attrs[5], &#125;) &#125; &#125;) fs.writeFileSync(jsonFile, JSON.stringify(jsonData)) consola.success(`Generate file success: $&#123;jsonFile&#125;`) &#125; run() export interface Item &#123; title: string datetime: number content_url: string content: string type: number cover_url: string &#125; export type Database = Item[] 在 package.json 文件中添加如下： &#123; ... \"scripts\": &#123; ... +++ \"convert\": \"tsx src/csvConverter.ts\" &#125; &#125; 在命令行中执行转换代码： npm run convert 执行完成后就可以看到出现了一个新文件：database.json。此时就可以在项目中直接引用该文件作为数据源啦。 ¶输出展示 前端使用 import 引入数据文件： import data from './asset/database.json' 随后就可以按照 React 的正常开发方式读取数据写业务代码了~~（程序员最擅长写的表格视图） 完整代码： import React from 'react' import ReactDOM from 'react-dom/client' import './index.css' import data from './asset/database.json' // 函数式组件 function Record(props) &#123; let record = props.record let time = new Date(record.datetime) //日期 var DD = String(time.getDate()).padStart(2, '0'); // 获取日 var MM = String(time.getMonth() + 1).padStart(2, '0'); //获取月份，1 月为 0 var yyyy = time.getFullYear(); // 获取年 // 时间 let hh = String(time.getHours()).padStart(2, '0'); //获取当前小时数(0-23) let mm = String(time.getMinutes()).padStart(2, '0'); //获取当前分钟数(0-59) let ss = String(time.getSeconds()).padStart(2, '0'); //获取当前秒数(0-59) let timeformat = yyyy + '-' + MM + '-' + DD + ' ' + hh + ':' + mm + ':' + ss; return ( &lt;tr> &lt;td>&#123;timeformat&#125;&lt;/td> &lt;td>&lt;a href=&#123;record.content_url&#125;>&#123;record.title&#125;&lt;/a>&lt;/td> &lt;td>&#123;record.content.length > 50?record.content.substring(0,50):record.content + '...'&#125;&lt;/td> &lt;/tr> ) &#125; // 传统组件 class DataBase extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; data: data &#125; &#125; render() &#123; let recordList = [] // 只展示 top 10 预览 for(var i = 0; i &lt;10;i++) &#123; recordList.push(&lt;Record record=&#123;this.state.data[i]&#125;/>) &#125; return ( &lt;div> &lt;p>loaded &#123;this.state.data.length&#125; records&lt;/p> &lt;table > &lt;td> &lt;th>时间&lt;/th> &lt;th>标题&lt;/th> &lt;th>正文&lt;/th> &lt;/td> &#123;recordList&#125; &lt;/table> &lt;/div> ) &#125; &#125; const root = ReactDOM.createRoot(document.getElementById(\"root\")); root.render(&lt;DataBase />); ¶总结 很久不写博客了，这次使用技术解决了一个实际问题，正好将博客重新营业起来~ 由于要去攻读博士学位，后面内容可能会更偏向于一些科研。不过也说不准┓( ´∀` )┏。"},{"title":"web 应用安全认证","path":"2020/11/17/web-应用安全认证/","text":"这篇指南带你创建一个Spring Security 管理资源安全的简单的 web 应用。 ¶你将会搭建… 一个 Spring MVC 的应用，页面被一个登陆表单保护，只有特定的用户可以访问。 ¶你需要… 15分钟时间 你喜欢的编辑器或 IDE JDK1.8+ Gradle 4+ 或 Maven3.2+ 可以直接直接在以下 IDE 中导入代码： Spring Tool Suite(STS) IntelliJ IDEA ¶如何完成指南 跟大多数 Spring 的指南一样，你需要从一个骨架项目启动，一步一步完成；或者直接跳过你已经很熟悉的配置步骤。两种方式得到的代码都能正确运行。 从骨架项目开始，移步从 Spring 启动器开始。 跳过基本步骤，做如下几步： 下载并解压源码项目或用 Git 命令： git clone https://github.com/spring-guides/gs-securing-web.git 打开到目录 gs-securing-web/initial 跳到创建不安全的应用 当你完成后，可以对比 gs-securing-web/complete 检查自己的代码。 ¶从 Spring 启动器开始 所有 Spring 应用都需要从 Spring 启动器开始。启动器提供快速的方式导入所有需要的依赖并自动执行很多启动项。本例需要 Spring Web 和 Thymeleaf 依赖。 下面是选择 Maven 时需要创建的 pom/xml 文件。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.3.2.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.example&lt;/groupId> &lt;artifactId>securing-web&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>securing-web&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 下面是选择 Gradle 时需要创建的 build.gradle 文件。 plugins &#123; id &#39;org.springframework.boot&#39; version &#39;2.3.2.RELEASE&#39; id &#39;io.spring.dependency-management&#39; version &#39;1.0.8.RELEASE&#39; id &#39;java&#39; &#125; group &#x3D; &#39;com.example&#39; version &#x3D; &#39;0.0.1-SNAPSHOT&#39; sourceCompatibility &#x3D; &#39;1.8&#39; repositories &#123; mavenCentral() &#125; dependencies &#123; implementation &#39;org.springframework.boot:spring-boot-starter-thymeleaf&#39; implementation &#39;org.springframework.boot:spring-boot-starter-web&#39; testImplementation(&#39;org.springframework.boot:spring-boot-starter-test&#39;) &#123; exclude group: &#39;org.junit.vintage&#39;, module: &#39;junit-vintage-engine&#39; &#125; &#125; test &#123; useJUnitPlatform() &#125; ¶创建不安全的 web 应用 在应用安全组件到 web 应用中前，需要先有一个 web 应用。本节带你创建一个简单的 web 应用程序，并在下一节中使用 Spring Security 接入安全。 应用包含 2 个简单页面：首页和“Hello World”页面。首页用如下 Thymeleaf 模板定义（位于）src/main/resources/templates/home.html： &lt;!DOCTYPE html> &lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"https://www.thymeleaf.org\" xmlns:sec=\"https://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"> &lt;head> &lt;title>Spring Security Example&lt;/title> &lt;/head> &lt;body> &lt;h1>Welcome!&lt;/h1> &lt;p>Click &lt;a th:href=\"@&#123;/hello&#125;\">here&lt;/a> to see a greeting.&lt;/p> &lt;/body> &lt;/html> 视图只是简单的包含一个指向 /hello页面的链接，页面定义如下（位于src/main/resources/templates/hello.html）： &lt;!DOCTYPE html> &lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"https://www.thymeleaf.org\" xmlns:sec=\"https://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"> &lt;head> &lt;title>Hello World!&lt;/title> &lt;/head> &lt;body> &lt;h1>Hello world!&lt;/h1> &lt;/body> &lt;/html> 这个 web 应用程序是基于 Spring MVC 的，因此需要配置Spring MVC 让视图控制器暴露出这些模板，下面列出（位于 src/main/java/com/example/securingweb/MvcConfig.java）展示了 Spring MVC 应用的配置类： package com.example.securingweb; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MvcConfig implements WebMvcConfigurer &#123; public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/home\").setViewName(\"home\"); registry.addViewController(\"/\").setViewName(\"home\"); registry.addViewController(\"/hello\").setViewName(\"hello\"); registry.addViewController(\"/login\").setViewName(\"login\"); &#125; &#125; addViewControllers() 方法（重写了 WebMvcConfigurer 类的同名方法）添加了 4 个视图控制器。2 个关联了定义在 home.html 文件的 home 视图，另 1 个关联了hello.html 文件的 hello 视图。第四个视图控制器关联了 login 视图，下一节中会创建。 此时，你可以跳转到“运行应用程序”并且运行不用登录就可访问任意位置的应用程序。 既然此时应用程序还没接入安全，这时来添加安全组件。 ¶配置 Spring Security 假设你希望阻止未授权用户访问 /hello 路径下的页面。当前，访问者点击首页链接，将会不受阻止看到问候页。你需要添加一层屏障迫使访问者看到页面前必须登录。 通过集成 Spring Security 到项目中实现。当 Spring Security 位于类路径下时，Spring 自动将所有 HTTP 接口用 “basic” 鉴权。不过你可以继续自定义安全配置。首先需要添加 Spring Security 到类路径下。 使用 Gradle，添加以下 2 行到 build.gradle 文件的 dependencies 一级下，（一个用在应用中，一个用来测试）： implementation &#39;org.springframework.boot:spring-boot-starter-security&#39; implementation &#39;org.springframework.security:spring-security-test&#39; 下面是完整的 build.gradle文件： plugins &#123; id &#39;org.springframework.boot&#39; version &#39;2.3.2.RELEASE&#39; id &#39;io.spring.dependency-management&#39; version &#39;1.0.8.RELEASE&#39; id &#39;java&#39; &#125; group &#x3D; &#39;com.example&#39; version &#x3D; &#39;0.0.1-SNAPSHOT&#39; sourceCompatibility &#x3D; &#39;1.8&#39; repositories &#123; mavenCentral() &#125; dependencies &#123; implementation &#39;org.springframework.boot:spring-boot-starter-thymeleaf&#39; implementation &#39;org.springframework.boot:spring-boot-starter-web&#39; implementation &#39;org.springframework.boot:spring-boot-starter-security&#39; implementation &#39;org.springframework.security:spring-security-test&#39; testImplementation(&#39;org.springframework.boot:spring-boot-starter-test&#39;) &#123; exclude group: &#39;org.junit.vintage&#39;, module: &#39;junit-vintage-engine&#39; &#125; &#125; test &#123; useJUnitPlatform() &#125; 使用 Maven 需要添加一下 2 部分（一个用于应用，一个用于测试）到 pom.xml 文件的 &lt;denpendencies&gt;元素下： &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-security&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.security&lt;/groupId> &lt;artifactId>spring-security-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> 下面是完整的 pom.xml文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.3.2.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.example&lt;/groupId> &lt;artifactId>securing-web&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>securing-web&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-security&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.security&lt;/groupId> &lt;artifactId>spring-security-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;exclusions> &lt;exclusion> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 以下安全配置（位于 src/main/java/com/example/securingweb/WebSecurityConfig.java）确保只有鉴权了的用户才能看到欢迎页： package com.example.securingweb; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.provisioning.InMemoryUserDetailsManager; @Configuration @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(\"/\", \"/home\").permitAll() .anyRequest().authenticated() .and() .formLogin() .loginPage(\"/login\") .permitAll() .and() .logout() .permitAll(); &#125; @Bean @Override public UserDetailsService userDetailsService() &#123; UserDetails user = User.withDefaultPasswordEncoder() .username(\"user\") .password(\"password\") .roles(\"USER\") .build(); return new InMemoryUserDetailsManager(user); &#125; &#125; WebSecurityConfig类被 @EnableWebSecurity 注解了，启用了 Spring Security 的 web 安全支持并提供了 Spring MVC 的集成。同时继承了 WebSecurityConfigurerAdapter类，重写了一组方法用来配置一些特定的 web 安全配置。 configure(HttpSecurity) 方法定义了哪些 URL 路径需要被鉴权。这里 / 和 /home 特别被标注不要鉴权，其他所有路径都要被鉴权。 当用户成功登录后，他们被重定向到之前请求的需要鉴权的页面。有一个自定义的 /login 页面（使用 loginPage() 指定），任何人都能访问。 userDetailsService()方法设置了单个用户的内存存储，给定了用户名为 user，密码为 password，角色为 USER。 现在需要创建登录页。已经有了 login 视图的视图控制器了，只需要创建视图即可，如下（位于 src/main/resources/templates/login.html）： &lt;!DOCTYPE html> &lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"https://www.thymeleaf.org\" xmlns:sec=\"https://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"> &lt;head> &lt;title>Spring Security Example &lt;/title> &lt;/head> &lt;body> &lt;div th:if=\"$&#123;param.error&#125;\"> Invalid username and password. &lt;/div> &lt;div th:if=\"$&#123;param.logout&#125;\"> You have been logged out. &lt;/div> &lt;form th:action=\"@&#123;/login&#125;\" method=\"post\"> &lt;div>&lt;label> User Name : &lt;input type=\"text\" name=\"username\"/> &lt;/label>&lt;/div> &lt;div>&lt;label> Password: &lt;input type=\"password\" name=\"password\"/> &lt;/label>&lt;/div> &lt;div>&lt;input type=\"submit\" value=\"Sign In\"/>&lt;/div> &lt;/form> &lt;/body> &lt;/html> Themeleaf 模板展示了一个记录用户名和密码的表单，并 post 方法传到 /login。Spring Security 配置后，提供一个拦截请求的过滤器并对用户鉴权。如果用户鉴权失败则会重定向到 /login?error，并且展示相关的错误信息。一旦成功登出，应用会重定向到 /login?logout，并且页面会展示成功信息。 最后，你需要提供访问者一种展示当前用户和登出的方式。因此，更新 hello.html 向当前用户打招呼并增加一个 Sign Out 表单，如下（位于 src/main/resources/templates/hello.html）： &lt;!DOCTYPE html> &lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"https://www.thymeleaf.org\" xmlns:sec=\"https://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"> &lt;head> &lt;title>Hello World!&lt;/title> &lt;/head> &lt;body> &lt;h1 th:inline=\"text\">Hello [[$&#123;#httpServletRequest.remoteUser&#125;]]!&lt;/h1> &lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"> &lt;input type=\"submit\" value=\"Sign Out\"/> &lt;/form> &lt;/body> &lt;/html> 使用 Spring Security 集成的 HttpServletRequest#getRemoteUser()来展示用户名。登出表单提交一个 POST 请求到 /logout。当成功登出后，用户会重定向到 /login?logout。 ¶运行应用 Spring 创建器已经为你创建了一个应用类。此时你不需要修改这个类。下面展示了这个应用启动类（位于 src/main/java/com/example/securingweb/SecuringWebApplication.java）： package com.example.securingweb; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class SecuringWebApplication &#123; public static void main(String[] args) throws Throwable &#123; SpringApplication.run(SecuringWebApplication.class, args); &#125; &#125; ¶构建可执行 JAR 文件 可以在命令行使用 Gradle 或 Maven 运行这个应用程序。也可以构建一个包含所有依赖、类和资源的可执行的 JAR 文件并直接运行它。构建 JAR 文件更方便去在开发生命周期中跨环境打包，版本管理和部署服务。 如果使用 Gradle，可以使用 ./gradlew bootRun 启动应用。或者也可以用 ./gradlew build 构建 JAR 文件然后用下面命令运行这个 JAR 文件： java -jar build/libs/gs-securng-web-0.1.0.jar 如果使用 Maven，可以使用 ./mvnw spring-boot:run 启动应用。或者也可以用 ./mvnw clean package 构建 JAR 文件然后用下面命令运行这个 JAR 文件： java -jar target/gs-securing-web-0.1.0.jar 一旦项目启动，在浏览器中打开 http://localhost:8080。你将会看到主页，如下图： 当你点击链接，会尝试将你带到 hello 的欢迎页。但是该页面是需要鉴权的，并且你还没登录，所以会重定向到登录页，如下图: 如果你是直接跳到这里，是未接入鉴权的版本，将不会看到登录页。需要返回去继续写剩下鉴权的代码。 在登录页，使用测试用户登录，分别使用 user 和 password 填入用户名和密码框。提交登录表单，将会被成功鉴权并重定向到欢迎页，如下图： 如果点击登出按钮，鉴权将会被注销，会返回到登录页，并有一条提示信息，告知你已经登出了。 ¶总结 恭喜！你已经开发了一个简单的用 Spring Security 鉴权的 web 应用。"},{"title":"GitLab CI 搭建指南","path":"2020/10/26/GitLab-CI-搭建指南/","text":"起因 事情的起因也是来自工作中跟我们日常密切相关，而又没有机会接触到的东西：CI。项目脚手架自带了 CI 脚本，只需要稍作修改就可以直接使用；GitLab 上的项目的 CI 配合也不需要我们管，直接使用Public Runner就行了。时间长了自然就对这方面比较感兴趣，想知道其中的原理。正好搭建了服务器，部署好了 GitLab，于是说干就干，开始着手做自己的 GitLab CI 配置。 过程 ¶CI 脚本 已经知道了在项目上执行的东西，包括推代码、打 tag 都会导致 CI 的自动执行，而什么情况执行什么 CI 的 stage 就由项目根目录下的.gitlab-ci.yml 文件决定。因此找到一个项目的 CI 文件看看是怎么写的： image: xxxxxx:maven-openjdk8-onbuild stages: - build - release test: stage: build script: - rm -rf test_target&#x2F;* &amp;&amp; mkdir -p test_target &amp;&amp; mvn -U clean package -Dmaven.test.skip&#x3D;true -P test - cp -a oms-web&#x2F;target&#x2F;oms-web.jar test_target&#x2F;ROOT.jar - chmod +x .&#x2F;test_target&#x2F;ROOT.jar - cp -rf .&#x2F;.dockerignore .&#x2F;test_target &amp;&amp; cp -rf .&#x2F;Dockerfile .&#x2F;test_target environment: test only: - &#x2F;^neo-java-test-.*$&#x2F; except: - branches artifacts: paths: - test_target&#x2F;* untracked: false neo-image-upload: stage: release image: xxxxx:docker19.06-base-image script: - mi_env&#x3D;$(echo $CI_COMMIT_TAG | awk -F &#39;-&#39; &#39;&#123;print $3&#125;&#39;) - cd .&#x2F;$mi_env&#39;_target&#39; - docker login hub.pf.xiaomi.com -u $HUBUSER -p $HUBPASS - docker build . -t xxxxxx.xxx.xxx&#x2F;$(echo $CI_COMMIT_TAG | awk -F &#39;-&#39; &#39;&#123;print $2&quot;-&quot;$3&#125;&#39;):$CI_COMMIT_TAG - docker push xxxxxxxxx.xxx.xxx]、&#x2F;$(echo $CI_COMMIT_TAG | awk -F &#39;-&#39; &#39;&#123;print $2&quot;-&quot;$3&#125;&#39;):$CI_COMMIT_TAG environment: name: neo only: - &#x2F;^neo-.*$&#x2F; except: - branches ... 首先上来是先定义CI 需要的基本 docker 镜像，不管你 CI 的目的是什么，最终都是要执行一段代码，这部分代码一定需要个环境去执行的，这个环境就是来自于声明的镜像类型。下面是定义了 2 个执行阶段：build 和 release。在 gitlab 平台上 CI 的过程状态图可以知道：这里是定义了他们执行的先后顺序：需要先构建好项目的产出可执行包，再推送到指定的容器中供启动。下面 2 部分则是定义了具体的 stage 的条件和执行的内容。stage：指定为哪个执行阶段。image：指定该阶段使用的镜像。script：该阶段执行的代码，一般为 shell 脚本。only：指定该阶段执行的触发条件，一般为分支或 tag 名。 根据上面的 ci 脚本，我定义一个最简单的 CI 脚本： image: docker:dind stages: - stage1 - stage2 stage-first: stage: stage1 script: - echo 'I am first executed!' only: - master artifacts: paths: - prod_target/* stage-second: stage: stage2 script: - echo 'I am second executed!' only: - master 定义了 2 个阶段，分别打印字符串。 ¶CI Runner 完成上面的 CI 脚本后我迫不及待的将分支合到 master 并推送到远程，期望他能立刻执行出结果。可是 GitLab 上显示的CI 状态为：Pending：No Runner available for pipeline。表明没有可以用来执行CI 的 Runner。那么就需要查找跟 Runner 相关的信息。得知：Runner 是支持多节点的独立部署的服务，在机器上启动 Runner 管理服务后注册一个新的 Runner，将其绑定到对应的 GitLab 上（可以绑定为一个 GitLab 库公用或者一个指定 repository 专用）就可以用来执行 CI 了。 ¶安装 gitlab-runner 此时我就去找 Runner 的安装了。我直接运行： sudo apt-get install gitlab-runner 安装成功，但是此时执行再执行： sudo gitlab-runner register 想注册一个 Runner 并绑定到我的 GitLab 上发现总是失败。 ¶Runner 的坑 经过一番搜索，知道了 GitLab 和 Runner 的版本有约束：8.X 版本的 GitLab 只支持 1.X 版本的 Runner 服务，而 apt 自动安装的为 13.X 版本的了，无法兼容。于是就需要开始搜索互联网上的 1.X 版本的 Runner 安装程序。 Runner 的 RELEASE：没有 1.X 版本。 Runner 的 Tag 列表：有 1.X 版本的 tag 但是没有 artifacts 产物。 各大镜像站：只有 10.X 开始版本的 Runner 安装程序。 看似已经山穷水尽了。忽然灵光一现：你虽然可以删除 RELEASE 的旧版本，但是你打版本 tag 的那次 CI 一定有输出到的路径，我就去追溯你那个生成 artifact 的路径不就可以了？果然，被我找到了导出到 AWS 的文件~ 找到了安装文件后就是顺利的安装过程~直接用命令说明吧： scp ~/Downloads/gitlab-ci-multi-runner_i386.deb haoxingxiao@XXX.XXX.XXX.XXX:~/ ssh XXX.XXX.XXX.XXX sudo dpkg -i gitlab-ci-multi-runner_i386.deb sudo gitlab-runner register (gitlab url) > http://XXXXXXXX.XXX.XXX/ci/ // 注意这里需要提供 /ci 路径 (token) > XXXXXXXXXXXXXX (runner name) > tencent-cloud-runner (tags) > tencent,common (allow untagged task?) > true (choose type:docker,shell &amp; etc.?) > docker ¶执行 CI 配置好 Runner 后就可以在 GitLab 上看到创建成功的 Runner 了: 这里我已经把租的阿里云服务器和腾讯云的服务器都配置上去了，构成了多个节点的 Runner 集群，当 CI 任务进入后会自动寻找空闲的 Runner 去执行。其实同一个容器绑定多个 Runner 也可以，不过负载就都在一台容器上了。 而刚才 Pending 的 CI 也开始执行了。学习了一下 CI 脚本的语法和知识，最终运行的结果如下图： 最终达到了搭建自己的自动化 CI 的环境~也利用了开源免费的 badge 服务 给项目的 README 增加了一个构建 CI 状态的徽章： 方便直观在项目主页查看状态。 后续 经过搭建 GitLab 和搭建 GitLab CI 2 步之后，下一步有好几个想要做的东西： Git Talk 服务 创建 Feishu SDK 项目，部署飞书通知的服务，并接入 CI，实现主动推送构建结果到飞书客户端。 进一步配置 Blog，目前 Blog 弄的比较仓促，很多信息和配置还没加上去。 今天就先写这么多吧~难得有摸鱼的机会弄自己的东西，希望还能一直保持这种热情做下去！☀️"},{"title":"近期好物分享","path":"2020/08/23/近期好物分享/","text":"¶背景 毕业一年了，钱没攒下几个，倒是把一些种了很久的草都拔了。2 次搬家购进的侧重点不太一样，第一次毕业搬家，对电子产品还是充满了好奇，更侧重电子产品，第二次则电子产品的草都拔完了，所以更侧重家居用品。"},{"title":"思维导图demo","path":"2020/07/26/思维导图demo/","text":"const data = { label: \"Central Topic\", children: [ { label: \"Main Topic 1\", children: [ { label: \"Main Topic 1\" } ] }, { label: \"Main Topic 2\" }, { label: \"Main Topic 3\" } ] } graph TD; A-->B; B-->C; A-->D;"},{"title":"如何实现复制Excel内容更新数据","path":"2020/05/15/如何实现复制Excel内容更新数据/","text":"¶背景 上季度在迭代通用策略的时候，曾经尝试迁移 PHP 版本的策略数据上传功能到 Java 后台，最后结果是配置管理部分的都完成了迁移（技术难度较低），但是相对而言，修改下载下来的 Excel 数据，然后复制内容到文本域里实现上传更新的功能就复杂的多，在上次的迁移中以失败告终，没有顺利迁移过来。 这个季度需要做的需求”智能调拨“也有类似的技术点：需要实现智能调拨方案的下载数据和修改数据，然后上传覆盖更新，还需要记录更新日志。不一样的业务场景，相似的技术点，不过最大的不同在于：这次的方案全盘由我自己来决策，需要什么字段自己加，需要执行什么操作自己构思；自由发挥的空间很大。因此心中就决心这次一定要把这个功能做好。 策略更新的信息 智能调拨更新的信息 ¶构思 在回忆上次开发通用策略的经验中和对本次智能调拨方案的拆解的过程中，我将上传数据更新的难点拆分为如下几个点： ¶表格数据的校验 数据进入后台第一步就是需要对传入的数据进行校验，其实不仅仅是上传更新，所有的接口都应该对入参进行校验，只是该场景下”非结构化数据——String“ 转换成”结构化数据——表格“所需要进行的校验相对更麻烦。我这里对智能调拨方案的数据校验分成2步： 第一步，表头的验证。验证表格的列数是否和原始数据一致，顺序是否一致。这里从库表中按照指定的排序（一般按照 id 排序，策略字段表有 order 字段，可以用自定义排序顺序）取出期望的列信息，并存入到 ArrayList 这种有序的列表中进行比对。 第二步，数据行数的验证。智能调拨方案导入需要保证数据行数和原始数据一致，因此这里把原始表中的记录也全数查出按照特定顺序(这里是用的商品 ID 排序)，并和入参逐行对比确认所有的行都是正确的顺序，并且和上一步的表头长度对比，确认每一行都不缺数。通用策略那边不需要保证行数一致，但是需要保证数据列一致，因此这一步也不能省略。 ¶数据项更新或新增的判断 数据项是新增还是更新是根据数据库中是否有记录决定的，智能调拨这里是根据原始数量是否等于0确定的，通用策略是通过索引字段是否一致确定的。两者形式不同，但都需要做更新/新增的判断。智能调拨判断的逻辑如下： updates.forEach(update -> &#123; if (update.getNumFrom() == 0) &#123; // 从无到有要新增记录 itemService.insertDetailRecord(update, planId); &#125; else if (update.getNumTo() == 0) &#123; // 从有到无要删除记录 itemService.deleteDetailRecord(update, planId); &#125; else &#123; // 否则更新记录 itemService.updateDetailRecord(update, planId); &#125; &#125;); 非常简单的实现了新增/更新判断。 通用策略的新增/更新判断需要根据索引字段确认，目前索引字段是通过取数据手动拼接实现的，后续计划在表中冗余该字段提高性能，同时也实现了对修改索引而不需要清空数据。这里判断新增/更新的逻辑如下： updates.foreach(update -> &#123; if(existIndexes.contains(update.getIndex())) &#123; strategyDataDoMapper.updateData(update, existIndexes.get(update.getIndex()), strategyId); &#125; else &#123; strategyDataDoMapper.insertData(update, strategyId); &#125; &#125;); 实现新增/更新判断同样也不复杂。 ¶维度值的转换 智能调拨方案的维度转换较为有限，仅仅需要仓库维度，场景也仅限于展示表头的仓库信息和日志的仓库信息，使用到维度转换只有一类：XmDimensionUtil.getRemote(&quot;mihome&quot;, mihomeId)。不过通用策略场景的所有字段都是通过配置实现，因此维度转换的场景更多样，维度转换+数据结构转换交织在一起，造成了上一次通用策略的接口迁移无比痛苦，总是转着转着就忘记当前的这个字段到底是名称还是键，还存在循环转换的潜在风险。 这次实现智能调拨的过程将这一部分思路整理清楚了，原则也很简单：信息只拓展不覆盖。用通俗的话说就是：把 key 和 name 都存起来，就不存在迷惑的可能了。这一句说起来简单，但是维度信息是用户配置，实践起来可能仍有一些坑需要踩。 ¶实现 考虑完所有的坑之后，实现起来就比较顺利了，也比较幸运，用了大约半天（4-6小时）一口气实现了这部分的代码。自我感觉在没有大量注释的情况下可读性还是不错的~这里直接抛出来供大家鞭策指正。 ¶service 代码 public String importTransferPlanDetail(Long planId, String data, Long operator) &#123; TransferPlanDO plan = transferPlanMapper.selectPlanByPlanId(planId); if (plan == null) &#123; throw new CommonException(ErrorCodeEnum.TRANSFER_PLAN_NOT_EXIST); &#125; if (plan.getStatus() != TransferConst.PlanStatus.CREATED) &#123; throw new CommonException(ErrorCodeEnum.TRANSFER_PLAN_NOT_EDITABLE); &#125; TransferPlanDetailBO bo = getTransferPlanDetail(planId); StringBuilder err = new StringBuilder(); try &#123; // 验证数据 + 获取数据的更新信息 List&lt;TransferPlanDetailRecordUpdateBO> updates = getUpdates(data, bo, err); if (err.length() > 0) &#123; return err.toString(); &#125; // 更新数据库详情数据 updates.forEach(update -> &#123; if (update.getNumFrom() == 0) &#123; // 从无到有要新增记录 itemService.insertDetailRecord(update, planId); &#125; else if (update.getNumTo() == 0) &#123; // 从有到无要删除记录 itemService.deleteDetailRecord(update, planId); &#125; else &#123; // 否则更新记录 itemService.updateDetailRecord(update, planId); &#125; &#125;); // 更新调拨方案更新时间 transferPlanMapper.updateTime(planId, System.currentTimeMillis() / 1000); // 写入日志 logService.logImport(operator, planId, updates); &#125; catch (Exception e) &#123; err.append(e.getMessage()); &#125; return err.toString(); &#125; ¶update 函数部分 private List&lt;TransferPlanDetailRecordUpdateBO> getUpdates(String data, TransferPlanDetailBO bo, StringBuilder err) &#123; String[] rows = data.split(\"[\\n]+\"); if (rows.length != bo.getDatas().size() + 1) &#123; throw new RuntimeException(\"数据行数错误！需要\" + (bo.getDatas().size() + 1) + \"行。\"); &#125; String[] headers = rows[0].split(\"[\\t]+\"); String[] dataRows = Arrays.copyOfRange(rows, 1, rows.length); PlanDetailHeaderBO[] existHeaders = bo.getHeaders().toArray(new PlanDetailHeaderBO[0]); HashMap&lt;String, Object>[] existDataRows = bo.getDatas().toArray(new HashMap[0]); if (existHeaders.length != headers.length) &#123; throw new RuntimeException(\"表头列数错误！需要\" + existHeaders.length + \"列。\"); &#125; // 验证表头 for (int i = 0; i &lt; existDataRows.length; i++) &#123; if (!headers[i].equals(existHeaders[i].getTitle())) &#123; err.append(\"表头缺少[\" + existHeaders[i].getTitle() + \"]\\n\"); &#125; &#125; List&lt;TransferPlanDetailRecordUpdateBO> result = new ArrayList&lt;>(); // 验证数据 for (int i = 0; i &lt; existDataRows.length; i++) &#123; String[] cells = dataRows[i].split(\"[\\t]+\"); HashMap&lt;String, Object> existRow = existDataRows[i]; String currentGoodsId = String.valueOf(existRow.get(\"goods_id\")); String currentGoodsName = (String) existRow.get(\"goods_name\"); String currentSku = (String) existRow.get(\"sku\"); if (cells.length != existRow.size()) &#123; throw new RuntimeException(\"第\" + (i + 1) + \"行数据列数错误！需要\" + existRow.size() + \"列。\\n\"); &#125; boolean goodsId = cells[0].equals(currentGoodsId); boolean goodsName = cells[1].equals(currentGoodsName); boolean sku = cells[2].equals(currentSku); if (!goodsId || !goodsName || !sku) &#123; err.append(\"第\" + (i + 1) + \"行数据商品信息有误，应为\" + currentGoodsName); &#125; for (int j = 3; j &lt; cells.length; j++) &#123; String currentCellInfo = existHeaders[j].getTitle() + \"调拨\" + currentGoodsName; try &#123; // 转换数据 Integer preNum = ((Double) existRow.get(existHeaders[j].getDataIndex())).intValue(); Integer newNum = Integer.parseInt(cells[j]); if (newNum &lt; 0) &#123; err.append(currentCellInfo + \"数据有误，请检查。\\n\"); continue; &#125; if (!preNum.equals(newNum)) &#123; String[] mihomePair = existHeaders[j].getDataIndex().split(\"-\"); String[] mihomeNamepair = existHeaders[j].getTitle().split(\"-\"); result.add(TransferPlanDetailRecordUpdateBO.builder() .goodsId(currentGoodsId) .goodsName(currentGoodsName) .sku(currentSku) .mihomeFrom(mihomePair[0]) .mihomeTo(mihomePair[1]) .mihomeFromName(mihomeNamepair[0]) .mihomeToName(mihomeNamepair[1]) .numFrom(preNum) .numTo(newNum).build()); &#125; &#125; catch (Exception e) &#123; err.append(currentCellInfo + \"数据有误，请检查。\\n\"); &#125; &#125; &#125; return result; &#125; getUpdates部分的代码一开始其实是准备把验证和读数分开做的~先验证格式正确性，取出入参的子集数据int[][]，再进行新建/更新判断，但是做的过程中发现没有必要，已经遍历到具体的数值了，对应的原始数值也正好能读到（已有数据的数据结构是用 HashMap 存储的，用dataRow.get([headerName])就可以得到），就直接去生成对应的变更记录列表了。由于违背了一开始的设计思路，所以可能看起来有点乱，如果你有更优雅的实现方式也可以跟我交流下~ ¶后续迭代计划 这里使用了100行不到的代码实现了对上传数据表格更新数据库的具体操作（当然还有前置读取原始数据的步骤），虽然代码不多，但是还是比较锻炼思维能力，我第二次开发才算比较满意的实现了预期的效果，后续计划将对上次未完成的通用策略的数据导入进行开发，进一步提高对这部分技术点的掌握。 平凡的业务中也有不平凡的闪光点~"},{"title":"学以致用","path":"2020/04/30/学以致用/","text":"¶刷题经历 最近一直在刷 Leetcode，刚好遇到一个 SQL 的题涉及到没有学习过的知识点。该题描述如下： 给定一个数据表 Department，数据格式如下： id revenue month 1 8000 Jan 2 9000 Jan 3 10000 Feb 1 7000 Feb 1 6000 Mar 要求返回的格式是上述数据的按 id 和 month 进行聚合，但是列同时还是按月进行切分的。也就是说，行方向是根据 id 区分的，列方向是根据 month 区分的，如下表： id Jan_Revenue Feb_Revenue Mar_Revenue … Dec_Revenue 1 8000 7000 6000 … null 2 9000 null null … null 3 null 10000 null … null 这种一看就知道用常规语法就无法做到，所以当时直接去查了答案，答案也很简单： select id, SUM(CASE WHEN month='Jan' then revenue else null end) as 'Jan_Revenue', SUM(CASE WHEN month='Feb' then revenue else null end) as 'Feb_Revenue', SUM(CASE WHEN month='Mar' then revenue else null end) as 'Mar_Revenue', SUM(CASE WHEN month='Apr' then revenue else null end) as 'Apr_Revenue', SUM(CASE WHEN month='May' then revenue else null end) as 'May_Revenue', SUM(CASE WHEN month='Jun' then revenue else null end) as 'Jun_Revenue', SUM(CASE WHEN month='Jul' then revenue else null end) as 'Jul_Revenue', SUM(CASE WHEN month='Aug' then revenue else null end) as 'Aug_Revenue', SUM(CASE WHEN month='Sep' then revenue else null end) as 'Sep_Revenue', SUM(CASE WHEN month='Oct' then revenue else null end) as 'Oct_Revenue', SUM(CASE WHEN month='Nov' then revenue else null end) as 'Nov_Revenue', SUM(CASE WHEN month='Dec' then revenue else null end) as 'Dec_Revenue' from Department group by id order by id; 其中重点部分就是 SUM(CASE WHEN XX THEN XX else XX END)，其中的 WHEN 和 THEN 既可以是字段也可以是函数也可以是简单的值，很简单，语法就能看懂在做什么，不多解释了。 ¶做完思考 由于题目的解法是网上直接搜的答案，当时就在想，SQL 题目的考察点都是偏向没见过的语法，都只能直接查结果，得不到练习思维的效果了，一度想要把 SQL 题过滤掉。最后还是决定留下，每次遇到 SQL 题就直接搜结果学习下，并且多做一道程序题来弥补。把 SQL 的题当做学习。 ¶🤟 👉 🎁 🍫 正如《阿甘正传》里说的那样：”Life is like a box of chocolate, you never konw what you’ll gonna get“。我也没想到这种不常用的 SQL 还会有排上用场的时候。 场景是这样的：现在提供一个接口，实现的是自动生成调拨方案，存在表中的结构是由方案ID、商品ID、发货仓库、收货仓库四个字段唯一确定的一条记录，字段还包括当前商品的名称、当前商品的调拨数量等信息。如下表： id plan_id goods_id goods_name from to number 1 31029 A123 小米10 Pro 31024 31028 20 上述的一条记录表示的是：创建的自动调拨方案 31029 中有一条调拨记录，需要将 20 只小米 10 Pro手机(ID: A123)从 31024 仓库调拨到 31028 仓库。 现在需要提供一个界面，供用户查询一个调拨方案的详表，其中每一行代表了一种商品，一列数据代表了一个[发货仓]-[收货仓]的对应关系，如果该商品在这个调拨关系上没有数据则留空。最终效果如下图（来自于系统原型图）： 一开始考虑的技术方案是，将表中对应的所有数据项都查询出来，然后通过程序去做数据的聚合，整理出来的思路如下： 显示调拨方案详情： - 查询得到List&lt;Item&gt; items - 所有的 MihomeFrom-MihomeTo pair 做成 HashSet - 生成 Headers - Sku 过滤成 HashSet sku - foreach sku in skus - - foreach item in items.filter(sku) - - data.add(item.mihomeFrom-item.mihomeTo, item.number) 导出报表：使用显示详情的接口，并将 header+data 的结果转换成 csv - header转换成 ArrayList - data 也转换成同大小的 ArrayList，并 search 到对应的值 后来回忆起做过的做过的 LeetCode 题目，可以看出，上表中的每一行记录对应了原型图中的表格的每一个格点，这个业务场景就完美契合了上面题目的考察点：对原始表中的数据进行特定情况的聚合，生成新的数据列。不同的地方在于，例题中的数据列是给定的12个月，而当前的业务需要根据数据的特点动态生成。这一难点在Mybatis中也比较好解决：Mapper.xml 作为DAL层访问数据库的代理，既可以传入参数，也支持一些简单的逻辑操作指令，比如for循环插入SUM函数就可以实现生成动态列的效果。 ¶解决方案 ¶1. 查询出所需的所有动态列数据 SQL： select mihome_from, mihome_to from plan_test as l where l.plan_id = 1; 结果集： mihome_from mihome_to 1 10 1 12 2 10 3 14 将上述结果用一个数据结构 List&lt;MihomePair&gt; 保存起来，在下一步中使用。 ¶2. 动态构建 SQL mapper.xml: &lt;select id=\"selectDetailTable\" resultType=\"java.util.HashMap\"> select sku, goods_id,goods_name, &lt;foreach collection=\"mihomePair\" index=\"index\" item=\"pair\" separator=\",\"> SUM(CASE WHEN mihome_from=#&#123;pair.from&#125; and mihome_to = #&#123;pair_to&#125; then number else null end) as '#&#123;pair.from&#125;-#&#123;pair_to&#125;' &lt;/foreach> from plan_test where plan_id = 1 group by sku,goods_id, goods_name &lt;/select> SQL 执行结果： ¶输出结果 结果集HashMap中的KeySet自身可以作为表头，稍转换下即可返回，数据项都符合前端需要的格式，也可以直接返回。 该结果可以进一步转换成 SKU 作为键的 List，供用户的更新操作方便操作原始数据。也可以将 KeySet 转换为 List，数据列从 Map 转换成数组，方便导出 CSV 格式的文件。 ¶项目实践 在智能调拨项目中将这个技术点应用到实践中，最终实现的效果如下： ** 请求响应 json ** ** 用户界面 ** ¶思考 这个问题看似简单，但是可以反映出一些有意思的观点：”世界上没有错误的道路，他们最终都走向正确“。不要放弃平时的积累，也许他们会在意想不到的时候给你一个bonus~"},{"title":"创建hexo脚本","path":"2020/01/06/创建hexo脚本/","text":"起因 本人创建Hexo脚本的痛点主要是2点： 我用 vs code 的终端运行 hexo 命令和管理资源文件，用 Typora 撰写文章，因此每次不管是新建文章还是预览还是发布都需要来回切换，步骤较多挺麻烦的。 博客源码的版本管理。之前写过好几篇博文，可是在一次装机的过程中忘记迁移，结果丢失了原始markdown的文章和配置文件，导致无法继续写下去了，只得重头开始!QAQ 脚本 基于以上2个原因，这里我创建了3个相关的脚本，还有一个麻烦一点正在实现中~ ¶1. 新建文章 cd ~/repos/blog-src hexo new \"&#123;query&#125;\" open source/_posts/&#123;query&#125;.md 核心是hexo new xx命令，创建了新md文件，并使用open命令使用默认方式（我设置的是Typora）打开该文件开始写文章。 ¶2. 本地运行博客 cd ~/repos/blog-src hexo clean hexo generate hexo server -p &#123;query&#125; open https://localhost:&#123;query&#125; 有点像git的提交和本地运行，就是用hexo的server本地运行命令,运行启动后需要打开浏览器访问本地地址。由于hexo server把当前的终端挂起了，因此需要将访问页面的命令换个地方启动，这里直接把启动Chrome，访问localhost:{query}的操作放在输入之后，虽然会暂时显示无法访问，但是由于Chrome开启了自动重载特性，所以起起来后还是能显示博客，就暂先这么实现了。 ¶3. 发布博客 cd ~/repos/blog-src git add . git commit -m \"update\" git push hexo g hexo d 发布博客需要先把项目的源码推到 github 上再执行部署，保证了源码和博客都得到同步。 ¶4. 编辑博客 在完成上述几个脚本后进一步，需要实现一个对当前已有博文的编辑功能，目标是实现列出当前所有博文并选择其中一个打开编辑。 参考了一些别人写的 python 的 workflow，实现了简单的获取所有博文并列出的功能： from os import listdir from os.path import isfile, join import sys from workflow import Workflow3, ICON_INFO reload(sys) sys.setdefaultencoding('utf-8') log = None mypath = '/Users/haoxingxiao/repos/blog-src/source/_posts' def main(wf): # 列出所有 markdown 文件 md_files = [f for f in listdir(mypath) if isfile(join(mypath, f)) and f.endswith('.md')] # 展示在 workflow 的下拉列表中，arg 表示输出给后续流程的参数字符串 for file in md_files : wf.add_item( file, mypath+ '/' +file, valid=True, icon=ICON_INFO, arg=mypath+ '/' + file ) wf.send_feedback() if __name__ == u\"__main__\": wf = Workflow3() log = wf.logger sys.exit(wf.run(main)) 后续再追加上一个 Run Script把{query}传递进去打开该文件即可。 效果： ¶base64 编码解码 完成上述的几个 workflow 后，继续一鼓作气完成了 base64 编码解码的 workflow。还增加了新的特性：filter，通过 Notification 提示用户转换成功还是失败。 还是用 python 的库执行核心的转换： import sys import base64 query = \"&#123;query&#125;\" sys.stdout.write(base64.b64decode(query)) 代码很简单，这部分流程控制更重要，如下图： workflow 流程图： 在执行完编码和解码后，根据内容是否为空判断是否成功，并使用 Notification 提示用户结果~成功了还会自动复制到剪贴板中。 ¶总结 使用 alfred 实现了博客文章的新增、编辑、本地运行和发布几个常用功能，对自己日常使用也非常有意义，而且对熟悉 workflow 库的语法也有帮助，后续可以进一步考虑把常用的一些工作流优化到 workflow~ e.p.: base64 的转换(Done)"},{"title":"规则配置平台","path":"2020/01/05/规则配置平台/","text":"¶1 业务背景 ¶1.1 是什么样的业务场景 当前业务场景中存在这样的一种较为特殊的需求：订单流的处理过程中，包括了一些决策的节点。如：拆单、合单、分快递等。这些场景存在共同点： 规则数量相对多，用单纯的分支代码逻辑实现起来麻烦且不优雅 规则随时可能会调整，如果用硬编码实现则调整周期长，不能满足业务场景的要求；此外，硬编码导致每次调整都需要开发的支持，加重了开发的负担。 规则的输入输出相对固定：输入一些字段的值，输出一些固定值的结果。不用的场景适合用同一套系统去维护。 此前 PHP 版本的系统中实现了一套较为简单的规则配置系统，但是其不管是输入还是输出，都是直接丢给用户一个输入框直接输入全文，用户面对这样的一个空白页面其实根本不知道填写什么。 因此，这版的 Java 新系统需求是需要实现一个更易用、拓展性更强的一个规则配置中心。暂时给的场景是规则数量较少的合单规则——当前仅有3条明确的合单规则，需要先将这些规则正确配置到系统中。 ¶1.2 初识 Drools 本来计划自行实现一个较为固定逻辑的字段读取、字段写入的一套对象处理流程： // precode for params RuleResult result = RuleParser.parse(ruleParams); // postcode for result 现在想想就能发现这种设计思路存在一些未考虑到的问题： 拓展性极差；该部分的配置完全依赖于当时的业务场景的需求，如果出现了新的需求，如需要调整后续的程序结构，则只能通过调整post代码实现，虽然这样也能满足当场的需求，但对于后续新需求的支持能力不足，维护起来仍然较为吃力。 规则匹配部分的算子设计；该部分的代码可能能实现，但是需要耗费一定时间设计+实现+调试。而且这部分的实现实际上属于底层支持，开发系统应该秉持的原则应该是：能用现成的工具就不要自己发明轮子。因此，这部分代码属实不必要。 偶然的机会，跟小爱部门的小康同学聊了聊，他给我说他们部门刚好需要调研一个开源工具：Drools规则引擎。从而打开了新世界的大门。 ¶2 技术原理 ¶2.1什么是规则引擎 规则引擎是基于规则的专家系统的核心部分，主要由三部分组成：规则库(Knowledge base)+Working Memory(Fact base)+推理机(规则引擎)，规则引擎根据既定事实和知识库按照一定的算法执行推理逻辑得到正确的结果。（Drools中文网） ¶2.2 Drools Drools 是一个基于Charles Forgy’s的RETE算法的，易于访问企业策略、易于调整以及易于管理的开源业务规则引擎，符合业内标准，速度快、效率高。 业务分析师人员或审核人员可以利用它轻松查看业务规则，从而检验是否已编码的规则执行了所需的业务规则。（还是Drools中文网） ¶2.3 Drools特点 支持DSL语法、XML语法定义规则。 采用RETE算法 开源产品 JBoss产品，成熟度高 ¶2.4 就决定是你了 不管是从技术栈（Java）还是从产品的功能上来看，Drools规则引擎都完美符合我们当前的业务场景的需要，而后我们又调研了它的算子支持、结果语句的支持、动态加载的实现等多个方面的特性，最终敲定采用该方案实现我们的规则配置中心。 ¶3 规则语法介绍 Drools采用特殊的DSL语法定义规则，因此需要先熟悉该部分的语法。 package com.sample.drools.rule import java.util.Map; function isZero(val) &#123; return val == 0; &#125; rule \"name\" no-loop true when $message:Message(status == 0) then System.out.println(\"fit\"); $message.setStatus(1); update($message); end imports：虽然是DSL，但是其基于Java语法，因此同样需要用 Java 的 import 语句实现类的引用。 functions：可以实现一些自定义函数，用在具体的规则中。由于使用 DSL 语法，在配置中心难以实现该部分代码校验，因此暂不实现该部分。 rules：该部分是规则语法的重点，其中包括了rule声明行、参数行、条件（when）、结果（then）等部分,下面依次介绍。 声明行：rule + “name”,一个规则的名称。 参数行：可以配置当前规则的参数，常见的有：no-loop, silience, agenda-group, auto-focus, activation-group, duration等，本项目用到了no-loop：是否重复执行当前规则，silience：优先级，activation-group：同组只会执行一条匹配的规则。 条件约束： 条件语句基本格式是：val:Object([field op value]*),一些例子： // 一般约束 $c : Cheese( type == “stilton”, price &lt; 10, age == “mature” ) // &amp;&amp; 和 || 约束 Cheese( type == “stilton” &amp;&amp; price &lt; 10, age == “mature” ) Cheese( type == “stilton” || price &lt; 10, age == “mature” ) // matches 操作 Cheese( type matches “(Buffalo)?/S*Mozerella” ) Cheese( type not matches “(Buffulo)?/S*Mozerella” ) // contains 操作 CheeseCounter( cheeses contains “stilton” ) CheeseCounter( cheeses not contains “cheddar” ) // memberof 操作 CheeseCounter( cheese memberof $matureCheeses ) CheeseCounter( cheese not memberof $matureCheeses ) // 字符串约束 Cheese( quantity == 5 ) Cheese( bestBefore &lt; “27-Oct-2007” ) Cheese( type == “stilton” ) Cheese( smelly == true ) // 绑定变量约束 Person( likes : favouriteCheese ) Cheese( type == likes ) // 返回值约束 Person( girlAge : age, sex == “F” ) Person( age == ( girlAge + 2) ), sex == ‘M’ ) // 复合值约束 Person( $cheese : favouriteCheese ) Cheese( type in ( “stilton”, “cheddar”, $cheese ) // 多重约束 Person( age ( (> 30 &amp;&amp; &lt; 40) || (> 20 &amp;&amp; &lt; 25) ) ) Person( age > 30 &amp;&amp; &lt; 40 || location == “london” ) // 内联 eval 约束 Person( girlAge : age, sex = “F” ) Person( eval( girlAge == boyAge + 2 ), sex = ‘M’ ) 执行操作：这部分的代码虽然可以直接写Java程序，但是应该简短，主要目的是插入和更新。 此外，还有query等其他规则成分，由于复杂度的限制，项目中不会采用这些功能，这里也不做介绍。 ¶4 将Drools应用到项目中 从上述的规则文件语法中可以看出，它的语法规则基于Java，是非常灵活的。但是本场景下需要将这部分的功能提供给业务方配置，因此过于灵活的配置方案不管是实现，还是交付使用成本都将会非常高，因此需要对规则进行一定程度的限制。 匹配的过程条件是多个对象、每个对象又有多个字段的判断，这部分的多次配置将会造成业务方一定困扰，因此这里我们简化为：传入一个对象，包括所有字段，业务仅选择字段和写对应每个字段的筛选条件即可。 imports：我们默认导入java.util.Map和java.util.HashMap作为结果集的类型，以及入参的对象的引用。 function 和 query：出于简化考虑暂不实现该部分的配置。 rule参数配置：这里使用了部分需要的参数： salience：优先级，这个参数是提供给用户配置的，确认执行的顺序。 activation-group：一个规则集中的规则都在同一个分组中，避免匹配完高优先级的规则后仍然进入低优先级的规则导致结果集字段被覆盖。 no-loop：本是用于防止规则重复匹配，这里结果操作中没有update操作，因此也不会出现重复匹配，为了保险还是设置一下该参数。 rule 条件配置：只提供一个条件对象和返回结果集合，用户能配置的部分为条件对象的字段的条件，条件间的关系暂定逗号分隔，都为且（&amp;&amp;）。 rule 结果配置：可以直接写 Java 程序，但是为了保证业务方的使用体验，因此这部分做了极大的限制：只能向传入的Map中写入键值对。而且键也是由管理员配置的字段中选取，从而保证了业务方面的使用不会有太高的门槛。 综合以上的条件，我们可以得到我们项目中使用的规则文件的基本结构： package com.sample.drools.rule import java.util.Map import java.util.HashMap import com.sample.RuleCondition rule &quot;[ruleName]&quot; no-loop: true salience: [priority] activation-group: sample when $condition: Condition([f1] [op] [v1], [f2] [op] [v2]) $resultMap: HashMap() then $resultMap.put([key1], [value1]) $resultMap.put([key2], [value2]) ... end 上述的代码，只有括号包含的值是用户配置的，而且大部分都为选项，最大程度降低了配置成本。但是为了保证健壮和灵活性，也需要将每个规则集的条件和结果定义交给更有经验的开发者配置，因此同样需要设计一个规则集和字段管理的管理员配置模块。 ¶5 功能设计 功能设计上参考之前通用策略部分，实现了“管理员侧”和“用户侧”2部分的管理系统，具体功能如下图： 管理员侧可以创建规则集，对应着应用规则的不同场景，同时可以修改删除；还需要实现规则集内所有条件字段、结果字段的新增调整，以供用户侧选择。 用户侧可以选择一个规则集，添加新的规则，添加的时候要同时在所有字段中选择所需要的条件字段、结果字段，并设置好他们的操作符和值，确认当前规则的执行流程。用户同样可以修改、删除规则。 管理员在编辑规则集和规则集字段的时候有使用状态约束，在使用中的规则集和字段是无法删除的；用户在编辑规则和字段的时候有规则引擎校验约束，如果填写的规则导致校验失败，同样是无法配置的。 ¶6 库表结构设计 原本计划用一套新库表结构实现该部分的数据存储，为了验证通用策略的拓展性，因此将通用规则部分的数据适配到通用策略的库表结构中。 不过比较好的是，该库表结构只需要进行少量的拓展即可实现对规则部分的支持。 策略集字段增加角色信息字段（role），是否必填（isRequired）。 策略集表增加type属性判断是规则还是策略。 规则文件和库表结构对应关系如下表： |规则文件字段|库表结构位置| |–|–| ||| ¶7 实现效果展示 ¶8 后续开发计划 ¶8.1 带有逻辑的规则语句的支持"},{"title":"通用策略文档","path":"2019/11/26/通用策略文档/","text":"¶项目背景 场景是根据一些条件去查询指定的结果，场景较多，如果每个场景都维护一套对应的库表和数据结构，成本过高而且不通用，这里用通用策略去配置，实现的效果是传入指定的策略code和条件数据可以得到对应的查询结果。 在很多场景下，我们需要根据一些条件去查询结果， ¶项目地址 前端地址 管理地址 测试环境 http://wl.be.test.mi.com/oms http://wl.be.test.mi.com/oms/#/admin/common-strategy 线上环境 http://wl.be.mi.com/oms http://wl.be.mi.com/oms/#/admin/common-strategy 如遇无法登陆请在工作台(测试/线上)添加系统权限。 ¶使用指南 ¶1. 创建策略集 ¶2. 定义策略集字段 ¶3. 创建策略 ¶4. 选择策略字段 ¶5. 下载策略和基础数据 ¶6. 填写好策略数据，并导入 ¶7. 定义该策略的匹配规则 ¶8. 通过系统第三方X5接口查询策略数据"}]